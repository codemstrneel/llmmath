QUESTION

Write a Python function to find the nth Bell number, and optimize it to handle cases where n can be as large as 1,000.

SOLUTION/TESTS

To find the nth Bell number, we can use dynamic programming to efficiently compute the sequence without recalculating overlapping subproblems. The Bell number \( B_n \) is defined such that it represents the number of ways to partition a set of \( n \) elements.

Here is the optimized dynamic programming approach to compute the nth Bell number:

<|Solution Begin|>
def solution(n):
    """
    Computes the nth Bell number using dynamic programming.
    """
    if n < 0:
        raise ValueError("n must be a non-negative integer")

    bell = [[0 for _ in range(n+1)] for _ in range(n+1)]
    bell[0][0] = 1

    for i in range(1, n+1):
        # Explicitly assign the first value
        bell[i][0] = bell[i-1][i-1]

        # Fill the rest of the row
        for j in range(1, i+1):
            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]

    return bell[n][0]
<|Solution End|>

<|Test Begin|>
from solution import solution

def test_bell_number_small():
    assert solution(0) == 1
    assert solution(1) == 1
    assert solution(2) == 2
    assert solution(3) == 5
    assert solution(4) == 15

def test_bell_number_medium():
    assert solution(5) == 52
    assert solution(6) == 203
    assert solution(10) == 115975

def test_bell_number_large():
    assert solution(15) == 1382958545
    # This test ensures the function can run on larger inputs
    assert solution(20) == 51724158235372  

def test_bell_number_edge_cases():
    with pytest.raises(ValueError):
        solution(-1)
<|Test End|>

These tests cover both basic and edge cases of computing Bell numbers, including runtime exceptions for invalid input. The Bell numbers used in the tests are confirmed from known sequences, such as those found in the OEIS (Online Encyclopedia of Integer Sequences).