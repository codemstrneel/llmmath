QUESTION

Write a Python function that checks if two given strings are isomorphic and then sorts each string using heap sort before returning the sorted strings.

SOLUTION/TESTS

To solve this problem, we need to:

1. Determine if two strings are isomorphic.
2. Sort each string using heap sort.
3. Return the sorted versions of both strings.

### Isomorphic Strings
Two strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`, with each character mapped to a different character, but preserved order in the mapping.

### Heap Sort
Heap sort is a comparison-based sorting technique based on a binary heap data structure. It is similar to selection sort in that it divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region.

Here's the implementation in Python:

<|Solution Begin|>
```python
def is_isomorphic(s, t):
    """
    Check if the strings s and t are isomorphic.
    """
    if len(s) != len(t):
        return False

    mapping_s_to_t = {}
    mapping_t_to_s = {}

    for char_s, char_t in zip(s, t):
        if char_s in mapping_s_to_t:
            if mapping_s_to_t[char_s] != char_t:
                return False
        if char_t in mapping_t_to_s:
            if mapping_t_to_s[char_t] != char_s:
                return False
        mapping_s_to_t[char_s] = char_t
        mapping_t_to_s[char_t] = char_s

    return True

def heapify(arr, n, i):
    """
    Heapify a subtree rooted with node i which is an index in arr[].
    n is the size of the heap.
    """
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[i] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    # Build a maxheap.
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)

    # Extract elements one by one
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

def solution(s, t):
    """
    Check if s and t are isomorphic, sort them using heap sort,
    and return the sorted strings.
    """
    if not is_isomorphic(s, t):
        return None, None
    
    # Convert strings to lists of characters
    arr_s = list(s)
    arr_t = list(t)
    
    # Sort using heap sort
    heap_sort(arr_s)
    heap_sort(arr_t)
    
    # Convert back to strings
    sorted_s = ''.join(arr_s)
    sorted_t = ''.join(arr_t)
    
    return sorted_s, sorted_t
```
<|Solution End|>

<|Test Begin|>
```python
from solution import solution

def test_isomorphic_strings_with_same_chars():
    s, t = "paper", "title"
    sorted_s, sorted_t = solution(s, t)
    assert sorted_s == "aeppr"
    assert sorted_t == "eiltt"

def test_non_isomorphic_strings():
    s, t = "foo", "bar"
    sorted_s, sorted_t = solution(s, t)
    assert sorted_s is None
    assert sorted_t is None

def test_identical_strings():
    s, t = "abc", "abc"
    sorted_s, sorted_t = solution(s, t)
    assert sorted_s == "abc"
    assert sorted_t == "abc"

def test_isomorphic_different_lengths():
    s, t = "ab", "a"
    sorted_s, sorted_t = solution(s, t)
    assert sorted_s is None
    assert sorted_t is None

def test_empty_strings():
    s, t = "", ""
    sorted_s, sorted_t = solution(s, t)
    assert sorted_s == ""
    assert sorted_t == ""
```
<|Test End|>

This implementation ensures that the strings are checked for isomorphism first, and if they are isomorphic, they are each sorted using heap sort. The tests cover various cases, including isomorphic strings, non-isomorphic strings, empty strings, and identical strings.