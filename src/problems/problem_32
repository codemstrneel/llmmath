QUESTION

Create a function that processes a list of dictionaries. Each dictionary has two keys: 'product', which maps to a string representing a product name, and 'prices', which maps to a list of floats representing the prices of the product in different stores. The function should perform the following tasks:

1. Sort the list of dictionaries in increasing order based on the median of the 'prices' list.
2. Identify the dictionary with the non-empty 'prices' list and the lowest median.
3. For the identified dictionary, calculate the difference between the maximum and minimum price, then multiply this result by the number of vowels in the 'product' string.
4. Return a tuple containing the 'product' from the identified dictionary and the final calculated value.

This task involves list manipulation, string operations, sorting based on computed medians, and arithmetic operations.

SOLUTION/TESTS

```python
<|Solution Begin|>
def solution(products):
    """
    Processes a list of product dictionaries and returns a tuple containing
    the product name of the dictionary with the lowest median price and a calculated value.
    
    Args:
    - products (list of dict): Each dict contains 'product' as a string
      and 'prices' as a list of floats.
    
    Returns:
    - tuple: (product name with lowest median price, calculated value).
    """
    from statistics import median

    # Step 1 & 2: Sort products by median and identify dictionary with non-empty lowest median
    sorted_products = sorted(
        (p for p in products if p['prices']), 
        key=lambda p: median(p['prices'])
    )

    if not sorted_products:
        return None, 0

    lowest_median_dict = sorted_products[0]

    # Step 3: Calculate the difference between max and min price, multiplied by vowels in product
    prices = lowest_median_dict['prices']
    max_min_diff = max(prices) - min(prices)
    vowels_count = sum(1 for char in lowest_median_dict['product'].lower() if char in 'aeiou')
    calculated_value = max_min_diff * vowels_count

    # Step 4: Return the 'product' and the calculated value
    return (lowest_median_dict['product'], calculated_value)
<|Solution End|>
<|Test Begin|>
def test_solution_single_product():
    assert solution([{'product': 'Widget', 'prices': [10.99, 9.99, 11.99]}]) == ('Widget', 6.0)

def test_solution_multiple_products():
    products = [
        {'product': 'Widget', 'prices': [10.99, 9.99, 11.99]},
        {'product': 'Gadget', 'prices': [14.99, 13.99, 12.99]},
        {'product': 'Doodad', 'prices': [5.99, 5.49, 5.79]},
    ]
    assert solution(products) == ('Doodad', 1.0)

def test_solution_empty_prices():
    products = [
        {'product': 'Widget', 'prices': []},
        {'product': 'Gadget', 'prices': [14.99, 13.99, 12.99]},
    ]
    assert solution(products) == ('Gadget', 6.0)

def test_solution_no_products():
    assert solution([]) == (None, 0)

def test_solution_all_empty_prices():
    products = [
        {'product': 'Widget', 'prices': []},
        {'product': 'Gadget', 'prices': []},
    ]
    assert solution(products) == (None, 0)

def test_solution_same_median():
    products = [
        {'product': 'Equal', 'prices': [2.0, 2.0, 2.0]},
        {'product': 'Same', 'prices': [1.0, 1.0, 1.0]},
    ]
    assert solution(products) == ('Same', 0.0)

def test_solution_vowels_counting():
    products = [
        {'product': 'Umbrella', 'prices': [1.0, 10.0]},
        {'product': 'Ai', 'prices': [5.0, 2.0]},
    ]
    assert solution(products) == ('Umbrella', 63.0)

def test_solution_case_insensitivity():
    products = [
        {'product': 'AeiOu', 'prices': [10, 0]},
    ]
    assert solution(products) == ('AeiOu', 50.0)
<|Test End|>
```