QUESTION

Write a function that takes a list of strings, where each string contains a set of 2D coordinates representing vertices of a polygon (e.g., "A(2,3) B(3,4) C(5,6)"). For each polygon, calculate the distance of each vertex from the origin (0,0) and sort these distances in increasing order. Then, check if the sum of distances (when considered as integer values) has a unit digit of 6. If it does, for the corresponding polygon, convert each coordinate of the vertices to polar format (distance and angle in radians with respect to x-axis, rounded to two decimal places). Return a list of strings where each string contains the transformed coordinates for polygons that meet the specified criterion. If no polygons meet the criterion, return an empty list.

SOLUTION/TESTS

<|Solution Begin|>
import math
import re

def to_polar(x, y):
    """Convert Cartesian coordinates to polar format."""
    distance = round(math.hypot(x, y), 2)
    angle = round(math.atan2(y, x), 2)
    return (distance, angle)

def solution(polygon_strings):
    result = []
    for polygon in polygon_strings:
        vertices = re.findall(r'[A-Z]\((-?\d+),(-?\d+)\)', polygon)
        distances = []
        for vertex in vertices:
            x, y = int(vertex[0]), int(vertex[1])
            dist = math.hypot(x, y)
            distances.append(dist)
        
        # Sort distances
        distances.sort()
        
        # Check sum of distances
        int_sum = sum(map(int, map(math.floor, distances)))
        if int_sum % 10 == 6:  # Check if the last digit is 6
            polar_vertices = []
            for vertex in vertices:
                x, y = int(vertex[0]), int(vertex[1])
                polar_vertices.append(to_polar(x, y))
            
            # Create the resulting polygon string
            polar_str = " ".join([f"({p[0]},{p[1]})" for p in polar_vertices])
            result.append(polar_str)
    
    return result
<|Solution End|>
<|Test Begin|>
from solution import solution

def test_solution_basic():
    input_data = [
        "A(3,4) B(6,8) C(0,5)",  # (5, 10, 5), floor sum = 20, last digit 0
        "A(1,2) B(2,2) C(3,3)",  # (2.24, 2.83, 4.24), floor sum = 8, last digit 8
        "A(6,8) B(8,6) C(0,10)"  # (10, 10, 10), floor sum = 30, last digit 0
    ]
    output_data = []
    assert solution(input_data) == output_data

def test_solution_valid_polygon():
    input_data = [
        "A(3,4) B(6,8) C(9,12)",  # (5, 10, 15), floor sum = 30, last digit 0
        "A(2,2) B(3,4) C(0,6)"   # (2.83, 5, 6), floor sum = 13, last digit 3
    ]
    output_data = [
        "(2.83,0.79) (5.0,0.93) (6.0,1.57)"
    ]
    assert solution(input_data) == output_data

def test_solution_all_valid():
    input_data = [
        "A(1,3) B(2,2) C(1,2)",  # (3.16, 2.83, 2.24), floor sum = 7, last digit 7
        "A(3,4) B(3,4) C(3,5)"   # (5, 5, 5.83), floor sum = 14, last digit 4
    ]
    output_data = []
    assert solution(input_data) == output_data

def test_solution_empty_input():
    input_data = []
    output_data = []
    assert solution(input_data) == output_data

def test_solution_zero_distance():
    input_data = [
        "A(0,0) B(0,0) C(0,0)"  # all distances are 0, sum is 0
    ]
    output_data = []
    assert solution(input_data) == output_data

def test_solution_complex_cases():
    input_data = [
        "A(0,6) B(2,2) C(1,3)",  # (6, 2.83, 3.16), floor sum = 11, last digit 1
        "A(0,5) B(5,0) C(3,4)"   # (5, 5, 5), floor sum = 15, last digit 5
    ]
    output_data = []
    assert solution(input_data) == output_data
<|Test End|>