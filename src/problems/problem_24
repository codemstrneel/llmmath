QUESTION

Write a function that accepts a list of tuples. Each tuple contains a string and a list of floating-point numbers. The function should identify the tuple where the list has the highest total sum of numbers reversed. Then, reverse the list of numbers in that tuple and calculate the sum of the reversed list. Find the tuple whose reversed list has a sum closest to the average of all original sums of reversed lists. For this tuple, sum only the positive numbers in the reversed list and check if this sum equals or exceeds half of the value of the highest number in the entire original list of floats across all tuples. Return a tuple containing the associated string with that tuple and a boolean indicating whether this condition is satisfied.

SOLUTION/TESTS

```python
<|Solution Begin|>
def solution(data):
    # Calculate the sum of each list in the tuples, reversed
    sums = [sum(reversed(lst)) for _, lst in data]
    
    # Find the tuple with the maximum sum of reversed list
    max_sum_index = sums.index(max(sums))
    
    # Calculate the average of all sums of reversed lists
    average_sum = sum(sums) / len(sums)
    
    # Find the tuple with the sum closest to the average
    min_diff = float('inf')
    closest_index = None
    for i, total in enumerate(sums):
        diff = abs(total - average_sum)
        if diff < min_diff:
            min_diff = diff
            closest_index = i
    
    # Use the closest index to find the associated list and corresponding string
    closest_string, closest_list = data[closest_index]
    
    # Reverse the list of numbers
    reversed_list = list(reversed(closest_list))
    
    # Sum only the positive numbers in the reversed list
    positive_sum = sum(num for num in reversed_list if num > 0)
    
    # Find the highest number in the entire original list of all tuples
    all_numbers = [num for _, lst in data for num in lst]
    highest_number = max(all_numbers)
    
    # Check if the sum of positive numbers in the reversed list meets the condition
    condition_met = positive_sum >= (highest_number / 2)
    
    # Return the associated string and the boolean condition result
    return (closest_string, condition_met)
<|Solution End|>

<|Test Begin|>
from solution import solution

def test_solution_single_tuple():
    data = [("A", [1.0, 2.0, 3.0])]
    assert solution(data) == ("A", True)

def test_solution_average_case():
    data = [
        ("A", [1.0, 2.0, 3.0]),  # reversed sum = 6.0
        ("B", [4.0, 5.0, -1.0]), # reversed sum = 8.0
        ("C", [3.0, 4.0, 5.0])   # reversed sum = 12.0
    ]
    assert solution(data) == ("B", True)

def test_solution_no_positive_sum_condition():
    data = [
        ("A", [-5.0, -2.0, -1.0]), # reversed sum = -8.0
        ("B", [0.0, -5.0, 1.0]),   # reversed sum = -4.0
        ("C", [5.0, -3.0, 2.0])    # reversed sum = 4.0
    ]
    assert solution(data) == ("B", False)

def test_solution_multiple_tuples():
    data = [
        ("A", [10.0, 20.0, 30.0]), # reversed sum = 60.0
        ("B", [40.0, 5.0, 7.0]),   # reversed sum = 52.0
        ("C", [-10.0, -20.0, -30.0]), # reversed sum = -60.0
        ("D", [40.0, 10.0, -50.0]) # reversed sum = 0.0
    ]
    assert solution(data) == ("A", False)

def test_solution_all_zeros():
    data = [
        ("A", [0.0, 0.0, 0.0]), # reversed sum = 0.0
        ("B", [0.0, 0.0, 0.0, 0.0]) # reversed sum = 0.0
    ]
    assert solution(data) == ("A", False)

<|Test End|>
```